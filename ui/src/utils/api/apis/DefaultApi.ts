/* tslint:disable */
/* eslint-disable */
/**
 * Nessie API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Branch,
    BranchFromJSON,
    BranchToJSON,
    Contents,
    ContentsFromJSON,
    ContentsToJSON,
    ContentsKey,
    ContentsKeyFromJSON,
    ContentsKeyToJSON,
    EntriesResponse,
    EntriesResponseFromJSON,
    EntriesResponseToJSON,
    LogResponse,
    LogResponseFromJSON,
    LogResponseToJSON,
    Merge,
    MergeFromJSON,
    MergeToJSON,
    MultiGetContentsRequest,
    MultiGetContentsRequestFromJSON,
    MultiGetContentsRequestToJSON,
    MultiGetContentsResponse,
    MultiGetContentsResponseFromJSON,
    MultiGetContentsResponseToJSON,
    NessieConfiguration,
    NessieConfigurationFromJSON,
    NessieConfigurationToJSON,
    Operations,
    OperationsFromJSON,
    OperationsToJSON,
    Reference,
    ReferenceFromJSON,
    ReferenceToJSON,
    Tag,
    TagFromJSON,
    TagToJSON,
    Transplant,
    TransplantFromJSON,
    TransplantToJSON,
} from '../models';

export interface AssignBranchRequest {
    branchName: string;
    expectedHash: string;
    branch?: Branch;
}

export interface AssignTagRequest {
    tagName: string;
    expectedHash: string;
    tag?: Tag;
}

export interface CommitMultipleOperationsRequest {
    branchName: string;
    expectedHash: string;
    message?: string;
    operations?: Operations;
}

export interface CreateReferenceRequest {
    reference?: Reference;
}

export interface DeleteBranchRequest {
    branchName: string;
    expectedHash: string;
}

export interface DeleteContentsRequest {
    key: ContentsKey;
    branch?: string;
    hash?: string;
    message?: string;
}

export interface DeleteTagRequest {
    tagName: string;
    expectedHash?: string;
}

export interface GetCommitLogRequest {
    ref: string;
}

export interface GetContentsRequest {
    key: ContentsKey;
    ref?: string;
}

export interface GetEntriesRequest {
    ref: string;
}

export interface GetMultipleContentsRequest {
    ref?: string;
    multiGetContentsRequest?: MultiGetContentsRequest;
}

export interface GetReferenceByNameRequest {
    ref: string;
}

export interface MergeRefIntoBranchRequest {
    branchName: string;
    expectedHash: string;
    merge?: Merge;
}

export interface SetContentsRequest {
    key: ContentsKey;
    hash: string;
    branch?: string;
    message?: string;
    contents?: Contents;
}

export interface TransplantCommitsIntoBranchRequest {
    branchName: string;
    expectedHash: string;
    message?: string;
    transplant?: Transplant;
}

/**
 * no description
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Set a branch to a specific hash
     */
    async assignBranchRaw(requestParameters: AssignBranchRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling assignBranch.');
        }

        if (requestParameters.expectedHash === null || requestParameters.expectedHash === undefined) {
            throw new runtime.RequiredError('expectedHash','Required parameter requestParameters.expectedHash was null or undefined when calling assignBranch.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BranchToJSON(requestParameters.branch),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set a branch to a specific hash
     */
    async assignBranch(requestParameters: AssignBranchRequest): Promise<void> {
        await this.assignBranchRaw(requestParameters);
    }

    /**
     * Set a tag to a specific hash
     */
    async assignTagRaw(requestParameters: AssignTagRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tagName === null || requestParameters.tagName === undefined) {
            throw new runtime.RequiredError('tagName','Required parameter requestParameters.tagName was null or undefined when calling assignTag.');
        }

        if (requestParameters.expectedHash === null || requestParameters.expectedHash === undefined) {
            throw new runtime.RequiredError('expectedHash','Required parameter requestParameters.expectedHash was null or undefined when calling assignTag.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/tag/{tagName}`.replace(`{${"tagName"}}`, encodeURIComponent(String(requestParameters.tagName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TagToJSON(requestParameters.tag),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set a tag to a specific hash
     */
    async assignTag(requestParameters: AssignTagRequest): Promise<void> {
        await this.assignTagRaw(requestParameters);
    }

    /**
     * commit multiple on default branch
     */
    async commitMultipleOperationsRaw(requestParameters: CommitMultipleOperationsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling commitMultipleOperations.');
        }

        if (requestParameters.expectedHash === null || requestParameters.expectedHash === undefined) {
            throw new runtime.RequiredError('expectedHash','Required parameter requestParameters.expectedHash was null or undefined when calling commitMultipleOperations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        if (requestParameters.message !== undefined) {
            queryParameters['message'] = requestParameters.message;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}/commit`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OperationsToJSON(requestParameters.operations),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * commit multiple on default branch
     */
    async commitMultipleOperations(requestParameters: CommitMultipleOperationsRequest): Promise<void> {
        await this.commitMultipleOperationsRaw(requestParameters);
    }

    /**
     * Create a new reference
     */
    async createReferenceRaw(requestParameters: CreateReferenceRequest): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/tree`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReferenceToJSON(requestParameters.reference),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new reference
     */
    async createReference(requestParameters: CreateReferenceRequest): Promise<void> {
        await this.createReferenceRaw(requestParameters);
    }

    /**
     * Delete a branch endpoint
     */
    async deleteBranchRaw(requestParameters: DeleteBranchRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling deleteBranch.');
        }

        if (requestParameters.expectedHash === null || requestParameters.expectedHash === undefined) {
            throw new runtime.RequiredError('expectedHash','Required parameter requestParameters.expectedHash was null or undefined when calling deleteBranch.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a branch endpoint
     */
    async deleteBranch(requestParameters: DeleteBranchRequest): Promise<void> {
        await this.deleteBranchRaw(requestParameters);
    }

    /**
     * Delete object content associated with key
     */
    async deleteContentsRaw(requestParameters: DeleteContentsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling deleteContents.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        if (requestParameters.hash !== undefined) {
            queryParameters['hash'] = requestParameters.hash;
        }

        if (requestParameters.message !== undefined) {
            queryParameters['message'] = requestParameters.message;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/contents/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete object content associated with key
     */
    async deleteContents(requestParameters: DeleteContentsRequest): Promise<void> {
        await this.deleteContentsRaw(requestParameters);
    }

    /**
     * Delete a tag
     */
    async deleteTagRaw(requestParameters: DeleteTagRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.tagName === null || requestParameters.tagName === undefined) {
            throw new runtime.RequiredError('tagName','Required parameter requestParameters.tagName was null or undefined when calling deleteTag.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tag/{tagName}`.replace(`{${"tagName"}}`, encodeURIComponent(String(requestParameters.tagName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a tag
     */
    async deleteTag(requestParameters: DeleteTagRequest): Promise<void> {
        await this.deleteTagRaw(requestParameters);
    }

    /**
     * Get all references
     */
    async getAllReferencesRaw(): Promise<runtime.ApiResponse<Array<Reference>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ReferenceFromJSON));
    }

    /**
     * Get all references
     */
    async getAllReferences(): Promise<Array<Reference>> {
        const response = await this.getAllReferencesRaw();
        return await response.value();
    }

    /**
     * Get commit log for a reference
     */
    async getCommitLogRaw(requestParameters: GetCommitLogRequest): Promise<runtime.ApiResponse<LogResponse>> {
        if (requestParameters.ref === null || requestParameters.ref === undefined) {
            throw new runtime.RequiredError('ref','Required parameter requestParameters.ref was null or undefined when calling getCommitLog.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tree/{ref}/log`.replace(`{${"ref"}}`, encodeURIComponent(String(requestParameters.ref))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LogResponseFromJSON(jsonValue));
    }

    /**
     * Get commit log for a reference
     */
    async getCommitLog(requestParameters: GetCommitLogRequest): Promise<LogResponse> {
        const response = await this.getCommitLogRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get server configuration
     */
    async getConfigRaw(): Promise<runtime.ApiResponse<NessieConfiguration>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NessieConfigurationFromJSON(jsonValue));
    }

    /**
     * Get server configuration
     */
    async getConfig(): Promise<NessieConfiguration> {
        const response = await this.getConfigRaw();
        return await response.value();
    }

    /**
     * Get object content associated with key
     */
    async getContentsRaw(requestParameters: GetContentsRequest): Promise<runtime.ApiResponse<Contents>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling getContents.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.ref !== undefined) {
            queryParameters['ref'] = requestParameters.ref;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/contents/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ContentsFromJSON(jsonValue));
    }

    /**
     * Get object content associated with key
     */
    async getContents(requestParameters: GetContentsRequest): Promise<Contents> {
        const response = await this.getContentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get default branch for commits and reads
     */
    async getDefaultBranchRaw(): Promise<runtime.ApiResponse<Branch>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tree`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BranchFromJSON(jsonValue));
    }

    /**
     * Get default branch for commits and reads
     */
    async getDefaultBranch(): Promise<Branch> {
        const response = await this.getDefaultBranchRaw();
        return await response.value();
    }

    /**
     * Fetch all entries for a given reference
     */
    async getEntriesRaw(requestParameters: GetEntriesRequest): Promise<runtime.ApiResponse<EntriesResponse>> {
        if (requestParameters.ref === null || requestParameters.ref === undefined) {
            throw new runtime.RequiredError('ref','Required parameter requestParameters.ref was null or undefined when calling getEntries.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tree/{ref}/entries`.replace(`{${"ref"}}`, encodeURIComponent(String(requestParameters.ref))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => EntriesResponseFromJSON(jsonValue));
    }

    /**
     * Fetch all entries for a given reference
     */
    async getEntries(requestParameters: GetEntriesRequest): Promise<EntriesResponse> {
        const response = await this.getEntriesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get multiple objects\' content
     */
    async getMultipleContentsRaw(requestParameters: GetMultipleContentsRequest): Promise<runtime.ApiResponse<MultiGetContentsResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.ref !== undefined) {
            queryParameters['ref'] = requestParameters.ref;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/contents`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MultiGetContentsRequestToJSON(requestParameters.multiGetContentsRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MultiGetContentsResponseFromJSON(jsonValue));
    }

    /**
     * Get multiple objects\' content
     */
    async getMultipleContents(requestParameters: GetMultipleContentsRequest): Promise<MultiGetContentsResponse> {
        const response = await this.getMultipleContentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Fetch details of a reference
     */
    async getReferenceByNameRaw(requestParameters: GetReferenceByNameRequest): Promise<runtime.ApiResponse<Reference>> {
        if (requestParameters.ref === null || requestParameters.ref === undefined) {
            throw new runtime.RequiredError('ref','Required parameter requestParameters.ref was null or undefined when calling getReferenceByName.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/trees/tree/{ref}`.replace(`{${"ref"}}`, encodeURIComponent(String(requestParameters.ref))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferenceFromJSON(jsonValue));
    }

    /**
     * Fetch details of a reference
     */
    async getReferenceByName(requestParameters: GetReferenceByNameRequest): Promise<Reference> {
        const response = await this.getReferenceByNameRaw(requestParameters);
        return await response.value();
    }

    /**
     * merge commits from mergeRef to ref endpoint
     */
    async mergeRefIntoBranchRaw(requestParameters: MergeRefIntoBranchRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling mergeRefIntoBranch.');
        }

        if (requestParameters.expectedHash === null || requestParameters.expectedHash === undefined) {
            throw new runtime.RequiredError('expectedHash','Required parameter requestParameters.expectedHash was null or undefined when calling mergeRefIntoBranch.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}/merge`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MergeToJSON(requestParameters.merge),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * merge commits from mergeRef to ref endpoint
     */
    async mergeRefIntoBranch(requestParameters: MergeRefIntoBranchRequest): Promise<void> {
        await this.mergeRefIntoBranchRaw(requestParameters);
    }

    /**
     * Update object content associated with key
     */
    async setContentsRaw(requestParameters: SetContentsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling setContents.');
        }

        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling setContents.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        if (requestParameters.hash !== undefined) {
            queryParameters['hash'] = requestParameters.hash;
        }

        if (requestParameters.message !== undefined) {
            queryParameters['message'] = requestParameters.message;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/contents/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ContentsToJSON(requestParameters.contents),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update object content associated with key
     */
    async setContents(requestParameters: SetContentsRequest): Promise<void> {
        await this.setContentsRaw(requestParameters);
    }

    /**
     * transplant commits from mergeRef to ref endpoint
     */
    async transplantCommitsIntoBranchRaw(requestParameters: TransplantCommitsIntoBranchRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling transplantCommitsIntoBranch.');
        }

        if (requestParameters.expectedHash === null || requestParameters.expectedHash === undefined) {
            throw new runtime.RequiredError('expectedHash','Required parameter requestParameters.expectedHash was null or undefined when calling transplantCommitsIntoBranch.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.expectedHash !== undefined) {
            queryParameters['expectedHash'] = requestParameters.expectedHash;
        }

        if (requestParameters.message !== undefined) {
            queryParameters['message'] = requestParameters.message;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/trees/branch/{branchName}/transplant`.replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransplantToJSON(requestParameters.transplant),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * transplant commits from mergeRef to ref endpoint
     */
    async transplantCommitsIntoBranch(requestParameters: TransplantCommitsIntoBranchRequest): Promise<void> {
        await this.transplantCommitsIntoBranchRaw(requestParameters);
    }

}
