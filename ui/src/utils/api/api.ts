/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Nessie API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface CommitMeta
 */
export interface CommitMeta {
    /**
     * 
     * @type {number}
     * @memberof CommitMeta
     */
    commitTime?: number;
    /**
     * 
     * @type {string}
     * @memberof CommitMeta
     */
    commiter?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitMeta
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitMeta
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof CommitMeta
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface Contents
 */
export interface Contents {
}

/**
 * 
 * @export
 * @interface ContentsKey
 */
export interface ContentsKey {
    /**
     * 
     * @type {ListString}
     * @memberof ContentsKey
     */
    elements?: ListString;
}

/**
 * 
 * @export
 * @interface ContentsWithKey
 */
export interface ContentsWithKey {
    /**
     * 
     * @type {Contents}
     * @memberof ContentsWithKey
     */
    contents?: Contents;
    /**
     * 
     * @type {ContentsKey}
     * @memberof ContentsWithKey
     */
    key?: ContentsKey;
}

/**
 * 
 * @export
 * @interface Delete
 */
export interface Delete {
    /**
     * 
     * @type {ContentsKey}
     * @memberof Delete
     */
    key?: ContentsKey;
}

/**
 * 
 * @export
 * @interface DeltaLakeTable
 */
export interface DeltaLakeTable {
    /**
     * 
     * @type {ListString}
     * @memberof DeltaLakeTable
     */
    checkpointLocationHistory?: ListString;
    /**
     * 
     * @type {string}
     * @memberof DeltaLakeTable
     */
    lastCheckpoint?: string;
    /**
     * 
     * @type {ListString}
     * @memberof DeltaLakeTable
     */
    metadataLocationHistory?: ListString;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Dialect {
    DREMIO = 'DREMIO',
    HIVE = 'HIVE',
    PRESTO = 'PRESTO',
    SPARK = 'SPARK'
}

/**
 * 
 * @export
 * @interface EntriesResponse
 */
export interface EntriesResponse {
    /**
     * 
     * @type {string}
     * @memberof EntriesResponse
     */
    token?: string;
    /**
     * 
     * @type {ListEntry}
     * @memberof EntriesResponse
     */
    entries?: ListEntry;
}

/**
 * 
 * @export
 * @interface Entry
 */
export interface Entry {
    /**
     * 
     * @type {ContentsKey}
     * @memberof Entry
     */
    name?: ContentsKey;
    /**
     * 
     * @type {Type}
     * @memberof Entry
     */
    type?: Type;
}

/**
 * 
 * @export
 * @interface Hash
 */
export interface Hash {
    /**
     * 
     * @type {string}
     * @memberof Hash
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Hash
     */
    hash?: string;
}

/**
 * 
 * @export
 * @interface HiveDatabase
 */
export interface HiveDatabase {
    /**
     * 
     * @type {Array<string>}
     * @memberof HiveDatabase
     */
    databaseDefinition?: Array<string>;
}

/**
 * 
 * @export
 * @interface HiveTable
 */
export interface HiveTable {
    /**
     * 
     * @type {ListB}
     * @memberof HiveTable
     */
    partitions?: ListB;
    /**
     * 
     * @type {Array<string>}
     * @memberof HiveTable
     */
    tableDefinition?: Array<string>;
}

/**
 * 
 * @export
 * @interface IcebergTable
 */
export interface IcebergTable {
    /**
     * 
     * @type {string}
     * @memberof IcebergTable
     */
    metadataLocation?: string;
}

/**
 * 
 * @export
 * @interface ListB
 */
export interface ListB extends Array<any> {
}

/**
 * 
 * @export
 * @interface ListCommitMeta
 */
export interface ListCommitMeta extends Array<CommitMeta> {
}

/**
 * 
 * @export
 * @interface ListContentsKey
 */
export interface ListContentsKey extends Array<ContentsKey> {
}

/**
 * 
 * @export
 * @interface ListContentsWithKey
 */
export interface ListContentsWithKey extends Array<ContentsWithKey> {
}

/**
 * 
 * @export
 * @interface ListEntry
 */
export interface ListEntry extends Array<Entry> {
}

/**
 * 
 * @export
 * @interface ListOperation
 */
export interface ListOperation extends Array<Operation> {
}

/**
 * 
 * @export
 * @interface ListReference
 */
export interface ListReference extends Array<Reference> {
}

/**
 * 
 * @export
 * @interface ListString
 */
export interface ListString extends Array<string> {
}

/**
 * 
 * @export
 * @interface LogResponse
 */
export interface LogResponse {
    /**
     * 
     * @type {string}
     * @memberof LogResponse
     */
    token?: string;
    /**
     * 
     * @type {ListCommitMeta}
     * @memberof LogResponse
     */
    operations?: ListCommitMeta;
}

/**
 * 
 * @export
 * @interface Merge
 */
export interface Merge {
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    fromHash?: string;
}

/**
 * 
 * @export
 * @interface MultiGetContentsRequest
 */
export interface MultiGetContentsRequest {
    /**
     * 
     * @type {ListContentsKey}
     * @memberof MultiGetContentsRequest
     */
    requestedKeys?: ListContentsKey;
}

/**
 * 
 * @export
 * @interface MultiGetContentsResponse
 */
export interface MultiGetContentsResponse {
    /**
     * 
     * @type {ListContentsWithKey}
     * @memberof MultiGetContentsResponse
     */
    contents?: ListContentsWithKey;
}

/**
 * 
 * @export
 * @interface NessieConfiguration
 */
export interface NessieConfiguration {
    /**
     * 
     * @type {string}
     * @memberof NessieConfiguration
     */
    defaultBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof NessieConfiguration
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
}

/**
 * 
 * @export
 * @interface Operations
 */
export interface Operations {
    /**
     * 
     * @type {ListOperation}
     * @memberof Operations
     */
    operations?: ListOperation;
}

/**
 * 
 * @export
 * @interface Put
 */
export interface Put {
    /**
     * 
     * @type {ContentsKey}
     * @memberof Put
     */
    key?: ContentsKey;
    /**
     * 
     * @type {Contents}
     * @memberof Put
     */
    contents?: Contents;
}

/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference {
}

/**
 * 
 * @export
 * @interface SqlView
 */
export interface SqlView {
    /**
     * 
     * @type {Dialect}
     * @memberof SqlView
     */
    dialect?: Dialect;
    /**
     * 
     * @type {string}
     * @memberof SqlView
     */
    sqlText?: string;
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Transplant
 */
export interface Transplant {
    /**
     * 
     * @type {ListString}
     * @memberof Transplant
     */
    hashesToTransplant?: ListString;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Type {
    DELTALAKETABLE = 'DELTA_LAKE_TABLE',
    HIVEDATABASE = 'HIVE_DATABASE',
    HIVETABLE = 'HIVE_TABLE',
    ICEBERGTABLE = 'ICEBERG_TABLE',
    UNKNOWN = 'UNKNOWN',
    VIEW = 'VIEW'
}

/**
 * 
 * @export
 * @interface Unchanged
 */
export interface Unchanged {
    /**
     * 
     * @type {ContentsKey}
     * @memberof Unchanged
     */
    key?: ContentsKey;
}


/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set a branch to a specific hash
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {Branch} [branch] New branch content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignBranch(branchName: string, expectedHash: string, branch?: Branch, options: any = {}): FetchArgs {
            // verify required parameter 'branchName' is not null or undefined
            if (branchName === null || branchName === undefined) {
                throw new RequiredError('branchName','Required parameter branchName was null or undefined when calling assignBranch.');
            }
            // verify required parameter 'expectedHash' is not null or undefined
            if (expectedHash === null || expectedHash === undefined) {
                throw new RequiredError('expectedHash','Required parameter expectedHash was null or undefined when calling assignBranch.');
            }
            const localVarPath = `/api/v1/trees/branch/{branchName}`
                .replace(`{${"branchName"}}`, encodeURIComponent(String(branchName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expectedHash !== undefined) {
                localVarQueryParameter['expectedHash'] = expectedHash;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Branch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(branch || {}) : (branch || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a tag to a specific hash
         * @param {string} tagName 
         * @param {string} expectedHash 
         * @param {Tag} [tag] New tag content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTag(tagName: string, expectedHash: string, tag?: Tag, options: any = {}): FetchArgs {
            // verify required parameter 'tagName' is not null or undefined
            if (tagName === null || tagName === undefined) {
                throw new RequiredError('tagName','Required parameter tagName was null or undefined when calling assignTag.');
            }
            // verify required parameter 'expectedHash' is not null or undefined
            if (expectedHash === null || expectedHash === undefined) {
                throw new RequiredError('expectedHash','Required parameter expectedHash was null or undefined when calling assignTag.');
            }
            const localVarPath = `/api/v1/trees/tag/{tagName}`
                .replace(`{${"tagName"}}`, encodeURIComponent(String(tagName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expectedHash !== undefined) {
                localVarQueryParameter['expectedHash'] = expectedHash;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tag || {}) : (tag || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary commit multiple on default branch
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {string} [message] 
         * @param {Operations} [operations] Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitMultipleOperations(branchName: string, expectedHash: string, message?: string, operations?: Operations, options: any = {}): FetchArgs {
            // verify required parameter 'branchName' is not null or undefined
            if (branchName === null || branchName === undefined) {
                throw new RequiredError('branchName','Required parameter branchName was null or undefined when calling commitMultipleOperations.');
            }
            // verify required parameter 'expectedHash' is not null or undefined
            if (expectedHash === null || expectedHash === undefined) {
                throw new RequiredError('expectedHash','Required parameter expectedHash was null or undefined when calling commitMultipleOperations.');
            }
            const localVarPath = `/api/v1/trees/branch/{branchName}/commit`
                .replace(`{${"branchName"}}`, encodeURIComponent(String(branchName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expectedHash !== undefined) {
                localVarQueryParameter['expectedHash'] = expectedHash;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(operations || {}) : (operations || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new reference
         * @param {Reference} [reference] Reference to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReference(reference?: Reference, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/trees/tree`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Reference" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(reference || {}) : (reference || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a branch endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch(branchName: string, expectedHash: string, options: any = {}): FetchArgs {
            // verify required parameter 'branchName' is not null or undefined
            if (branchName === null || branchName === undefined) {
                throw new RequiredError('branchName','Required parameter branchName was null or undefined when calling deleteBranch.');
            }
            // verify required parameter 'expectedHash' is not null or undefined
            if (expectedHash === null || expectedHash === undefined) {
                throw new RequiredError('expectedHash','Required parameter expectedHash was null or undefined when calling deleteBranch.');
            }
            const localVarPath = `/api/v1/trees/branch/{branchName}`
                .replace(`{${"branchName"}}`, encodeURIComponent(String(branchName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expectedHash !== undefined) {
                localVarQueryParameter['expectedHash'] = expectedHash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete object content associated with key
         * @param {ContentsKey} key 
         * @param {string} [branch] 
         * @param {string} [hash] 
         * @param {string} [message] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContents(key: ContentsKey, branch?: string, hash?: string, message?: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteContents.');
            }
            const localVarPath = `/api/v1/contents/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag
         * @param {string} tagName 
         * @param {string} [expectedHash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tagName: string, expectedHash?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tagName' is not null or undefined
            if (tagName === null || tagName === undefined) {
                throw new RequiredError('tagName','Required parameter tagName was null or undefined when calling deleteTag.');
            }
            const localVarPath = `/api/v1/trees/tag/{tagName}`
                .replace(`{${"tagName"}}`, encodeURIComponent(String(tagName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expectedHash !== undefined) {
                localVarQueryParameter['expectedHash'] = expectedHash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all references
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReferences(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/trees`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get commit log for a reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitLog(ref: string, options: any = {}): FetchArgs {
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling getCommitLog.');
            }
            const localVarPath = `/api/v1/trees/tree/{ref}/log`
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get object content associated with key
         * @param {ContentsKey} key 
         * @param {string} [ref] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContents(key: ContentsKey, ref?: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getContents.');
            }
            const localVarPath = `/api/v1/contents/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get default branch for commits and reads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultBranch(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/trees/tree`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all entries for a given reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntries(ref: string, options: any = {}): FetchArgs {
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling getEntries.');
            }
            const localVarPath = `/api/v1/trees/tree/{ref}/entries`
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get multiple objects' content
         * @param {string} [ref] 
         * @param {MultiGetContentsRequest} [multiGetContentsRequest] Keys to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleContents(ref?: string, multiGetContentsRequest?: MultiGetContentsRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/contents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MultiGetContentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(multiGetContentsRequest || {}) : (multiGetContentsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch details of a reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceByName(ref: string, options: any = {}): FetchArgs {
            // verify required parameter 'ref' is not null or undefined
            if (ref === null || ref === undefined) {
                throw new RequiredError('ref','Required parameter ref was null or undefined when calling getReferenceByName.');
            }
            const localVarPath = `/api/v1/trees/tree/{ref}`
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary merge commits from mergeRef to ref endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {Merge} [merge] Merge operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeRefIntoBranch(branchName: string, expectedHash: string, merge?: Merge, options: any = {}): FetchArgs {
            // verify required parameter 'branchName' is not null or undefined
            if (branchName === null || branchName === undefined) {
                throw new RequiredError('branchName','Required parameter branchName was null or undefined when calling mergeRefIntoBranch.');
            }
            // verify required parameter 'expectedHash' is not null or undefined
            if (expectedHash === null || expectedHash === undefined) {
                throw new RequiredError('expectedHash','Required parameter expectedHash was null or undefined when calling mergeRefIntoBranch.');
            }
            const localVarPath = `/api/v1/trees/branch/{branchName}/merge`
                .replace(`{${"branchName"}}`, encodeURIComponent(String(branchName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expectedHash !== undefined) {
                localVarQueryParameter['expectedHash'] = expectedHash;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Merge" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(merge || {}) : (merge || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update object content associated with key
         * @param {ContentsKey} key 
         * @param {string} hash 
         * @param {string} [branch] 
         * @param {string} [message] 
         * @param {Contents} [contents] Contents to be upserted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContents(key: ContentsKey, hash: string, branch?: string, message?: string, contents?: Contents, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling setContents.');
            }
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling setContents.');
            }
            const localVarPath = `/api/v1/contents/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Contents" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(contents || {}) : (contents || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary transplant commits from mergeRef to ref endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {string} [message] 
         * @param {Transplant} [transplant] Hashes to transplant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transplantCommitsIntoBranch(branchName: string, expectedHash: string, message?: string, transplant?: Transplant, options: any = {}): FetchArgs {
            // verify required parameter 'branchName' is not null or undefined
            if (branchName === null || branchName === undefined) {
                throw new RequiredError('branchName','Required parameter branchName was null or undefined when calling transplantCommitsIntoBranch.');
            }
            // verify required parameter 'expectedHash' is not null or undefined
            if (expectedHash === null || expectedHash === undefined) {
                throw new RequiredError('expectedHash','Required parameter expectedHash was null or undefined when calling transplantCommitsIntoBranch.');
            }
            const localVarPath = `/api/v1/trees/branch/{branchName}/transplant`
                .replace(`{${"branchName"}}`, encodeURIComponent(String(branchName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expectedHash !== undefined) {
                localVarQueryParameter['expectedHash'] = expectedHash;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Transplant" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(transplant || {}) : (transplant || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set a branch to a specific hash
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {Branch} [branch] New branch content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignBranch(branchName: string, expectedHash: string, branch?: Branch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).assignBranch(branchName, expectedHash, branch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set a tag to a specific hash
         * @param {string} tagName 
         * @param {string} expectedHash 
         * @param {Tag} [tag] New tag content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTag(tagName: string, expectedHash: string, tag?: Tag, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).assignTag(tagName, expectedHash, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary commit multiple on default branch
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {string} [message] 
         * @param {Operations} [operations] Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitMultipleOperations(branchName: string, expectedHash: string, message?: string, operations?: Operations, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).commitMultipleOperations(branchName, expectedHash, message, operations, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new reference
         * @param {Reference} [reference] Reference to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReference(reference?: Reference, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createReference(reference, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a branch endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch(branchName: string, expectedHash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).deleteBranch(branchName, expectedHash, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete object content associated with key
         * @param {ContentsKey} key 
         * @param {string} [branch] 
         * @param {string} [hash] 
         * @param {string} [message] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContents(key: ContentsKey, branch?: string, hash?: string, message?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).deleteContents(key, branch, hash, message, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a tag
         * @param {string} tagName 
         * @param {string} [expectedHash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tagName: string, expectedHash?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).deleteTag(tagName, expectedHash, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all references
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReferences(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListReference> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getAllReferences(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get commit log for a reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitLog(ref: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LogResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getCommitLog(ref, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NessieConfiguration> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getConfig(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get object content associated with key
         * @param {ContentsKey} key 
         * @param {string} [ref] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContents(key: ContentsKey, ref?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contents> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getContents(key, ref, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get default branch for commits and reads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultBranch(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Branch> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getDefaultBranch(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch all entries for a given reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntries(ref: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntriesResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getEntries(ref, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get multiple objects' content
         * @param {string} [ref] 
         * @param {MultiGetContentsRequest} [multiGetContentsRequest] Keys to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleContents(ref?: string, multiGetContentsRequest?: MultiGetContentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MultiGetContentsResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getMultipleContents(ref, multiGetContentsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch details of a reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceByName(ref: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getReferenceByName(ref, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary merge commits from mergeRef to ref endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {Merge} [merge] Merge operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeRefIntoBranch(branchName: string, expectedHash: string, merge?: Merge, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).mergeRefIntoBranch(branchName, expectedHash, merge, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update object content associated with key
         * @param {ContentsKey} key 
         * @param {string} hash 
         * @param {string} [branch] 
         * @param {string} [message] 
         * @param {Contents} [contents] Contents to be upserted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContents(key: ContentsKey, hash: string, branch?: string, message?: string, contents?: Contents, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).setContents(key, hash, branch, message, contents, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary transplant commits from mergeRef to ref endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {string} [message] 
         * @param {Transplant} [transplant] Hashes to transplant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transplantCommitsIntoBranch(branchName: string, expectedHash: string, message?: string, transplant?: Transplant, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).transplantCommitsIntoBranch(branchName, expectedHash, message, transplant, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Set a branch to a specific hash
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {Branch} [branch] New branch content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignBranch(branchName: string, expectedHash: string, branch?: Branch, options?: any) {
            return DefaultApiFp(configuration).assignBranch(branchName, expectedHash, branch, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set a tag to a specific hash
         * @param {string} tagName 
         * @param {string} expectedHash 
         * @param {Tag} [tag] New tag content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTag(tagName: string, expectedHash: string, tag?: Tag, options?: any) {
            return DefaultApiFp(configuration).assignTag(tagName, expectedHash, tag, options)(fetch, basePath);
        },
        /**
         * 
         * @summary commit multiple on default branch
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {string} [message] 
         * @param {Operations} [operations] Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitMultipleOperations(branchName: string, expectedHash: string, message?: string, operations?: Operations, options?: any) {
            return DefaultApiFp(configuration).commitMultipleOperations(branchName, expectedHash, message, operations, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new reference
         * @param {Reference} [reference] Reference to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReference(reference?: Reference, options?: any) {
            return DefaultApiFp(configuration).createReference(reference, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a branch endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch(branchName: string, expectedHash: string, options?: any) {
            return DefaultApiFp(configuration).deleteBranch(branchName, expectedHash, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete object content associated with key
         * @param {ContentsKey} key 
         * @param {string} [branch] 
         * @param {string} [hash] 
         * @param {string} [message] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContents(key: ContentsKey, branch?: string, hash?: string, message?: string, options?: any) {
            return DefaultApiFp(configuration).deleteContents(key, branch, hash, message, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a tag
         * @param {string} tagName 
         * @param {string} [expectedHash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tagName: string, expectedHash?: string, options?: any) {
            return DefaultApiFp(configuration).deleteTag(tagName, expectedHash, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all references
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReferences(options?: any) {
            return DefaultApiFp(configuration).getAllReferences(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get commit log for a reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommitLog(ref: string, options?: any) {
            return DefaultApiFp(configuration).getCommitLog(ref, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any) {
            return DefaultApiFp(configuration).getConfig(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get object content associated with key
         * @param {ContentsKey} key 
         * @param {string} [ref] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContents(key: ContentsKey, ref?: string, options?: any) {
            return DefaultApiFp(configuration).getContents(key, ref, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get default branch for commits and reads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultBranch(options?: any) {
            return DefaultApiFp(configuration).getDefaultBranch(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch all entries for a given reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntries(ref: string, options?: any) {
            return DefaultApiFp(configuration).getEntries(ref, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get multiple objects' content
         * @param {string} [ref] 
         * @param {MultiGetContentsRequest} [multiGetContentsRequest] Keys to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleContents(ref?: string, multiGetContentsRequest?: MultiGetContentsRequest, options?: any) {
            return DefaultApiFp(configuration).getMultipleContents(ref, multiGetContentsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch details of a reference
         * @param {string} ref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceByName(ref: string, options?: any) {
            return DefaultApiFp(configuration).getReferenceByName(ref, options)(fetch, basePath);
        },
        /**
         * 
         * @summary merge commits from mergeRef to ref endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {Merge} [merge] Merge operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeRefIntoBranch(branchName: string, expectedHash: string, merge?: Merge, options?: any) {
            return DefaultApiFp(configuration).mergeRefIntoBranch(branchName, expectedHash, merge, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update object content associated with key
         * @param {ContentsKey} key 
         * @param {string} hash 
         * @param {string} [branch] 
         * @param {string} [message] 
         * @param {Contents} [contents] Contents to be upserted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContents(key: ContentsKey, hash: string, branch?: string, message?: string, contents?: Contents, options?: any) {
            return DefaultApiFp(configuration).setContents(key, hash, branch, message, contents, options)(fetch, basePath);
        },
        /**
         * 
         * @summary transplant commits from mergeRef to ref endpoint
         * @param {string} branchName 
         * @param {string} expectedHash 
         * @param {string} [message] 
         * @param {Transplant} [transplant] Hashes to transplant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transplantCommitsIntoBranch(branchName: string, expectedHash: string, message?: string, transplant?: Transplant, options?: any) {
            return DefaultApiFp(configuration).transplantCommitsIntoBranch(branchName, expectedHash, message, transplant, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Set a branch to a specific hash
     * @param {string} branchName 
     * @param {string} expectedHash 
     * @param {Branch} [branch] New branch content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignBranch(branchName: string, expectedHash: string, branch?: Branch, options?: any) {
        return DefaultApiFp(this.configuration).assignBranch(branchName, expectedHash, branch, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set a tag to a specific hash
     * @param {string} tagName 
     * @param {string} expectedHash 
     * @param {Tag} [tag] New tag content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public assignTag(tagName: string, expectedHash: string, tag?: Tag, options?: any) {
        return DefaultApiFp(this.configuration).assignTag(tagName, expectedHash, tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary commit multiple on default branch
     * @param {string} branchName 
     * @param {string} expectedHash 
     * @param {string} [message] 
     * @param {Operations} [operations] Operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public commitMultipleOperations(branchName: string, expectedHash: string, message?: string, operations?: Operations, options?: any) {
        return DefaultApiFp(this.configuration).commitMultipleOperations(branchName, expectedHash, message, operations, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new reference
     * @param {Reference} [reference] Reference to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createReference(reference?: Reference, options?: any) {
        return DefaultApiFp(this.configuration).createReference(reference, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a branch endpoint
     * @param {string} branchName 
     * @param {string} expectedHash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteBranch(branchName: string, expectedHash: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteBranch(branchName, expectedHash, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete object content associated with key
     * @param {ContentsKey} key 
     * @param {string} [branch] 
     * @param {string} [hash] 
     * @param {string} [message] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteContents(key: ContentsKey, branch?: string, hash?: string, message?: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteContents(key, branch, hash, message, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a tag
     * @param {string} tagName 
     * @param {string} [expectedHash] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteTag(tagName: string, expectedHash?: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteTag(tagName, expectedHash, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all references
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllReferences(options?: any) {
        return DefaultApiFp(this.configuration).getAllReferences(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get commit log for a reference
     * @param {string} ref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCommitLog(ref: string, options?: any) {
        return DefaultApiFp(this.configuration).getCommitLog(ref, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfig(options?: any) {
        return DefaultApiFp(this.configuration).getConfig(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get object content associated with key
     * @param {ContentsKey} key 
     * @param {string} [ref] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContents(key: ContentsKey, ref?: string, options?: any) {
        return DefaultApiFp(this.configuration).getContents(key, ref, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get default branch for commits and reads
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDefaultBranch(options?: any) {
        return DefaultApiFp(this.configuration).getDefaultBranch(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch all entries for a given reference
     * @param {string} ref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEntries(ref: string, options?: any) {
        return DefaultApiFp(this.configuration).getEntries(ref, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get multiple objects' content
     * @param {string} [ref] 
     * @param {MultiGetContentsRequest} [multiGetContentsRequest] Keys to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMultipleContents(ref?: string, multiGetContentsRequest?: MultiGetContentsRequest, options?: any) {
        return DefaultApiFp(this.configuration).getMultipleContents(ref, multiGetContentsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch details of a reference
     * @param {string} ref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getReferenceByName(ref: string, options?: any) {
        return DefaultApiFp(this.configuration).getReferenceByName(ref, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary merge commits from mergeRef to ref endpoint
     * @param {string} branchName 
     * @param {string} expectedHash 
     * @param {Merge} [merge] Merge operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mergeRefIntoBranch(branchName: string, expectedHash: string, merge?: Merge, options?: any) {
        return DefaultApiFp(this.configuration).mergeRefIntoBranch(branchName, expectedHash, merge, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update object content associated with key
     * @param {ContentsKey} key 
     * @param {string} hash 
     * @param {string} [branch] 
     * @param {string} [message] 
     * @param {Contents} [contents] Contents to be upserted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setContents(key: ContentsKey, hash: string, branch?: string, message?: string, contents?: Contents, options?: any) {
        return DefaultApiFp(this.configuration).setContents(key, hash, branch, message, contents, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary transplant commits from mergeRef to ref endpoint
     * @param {string} branchName 
     * @param {string} expectedHash 
     * @param {string} [message] 
     * @param {Transplant} [transplant] Hashes to transplant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transplantCommitsIntoBranch(branchName: string, expectedHash: string, message?: string, transplant?: Transplant, options?: any) {
        return DefaultApiFp(this.configuration).transplantCommitsIntoBranch(branchName, expectedHash, message, transplant, options)(this.fetch, this.basePath);
    }

}

